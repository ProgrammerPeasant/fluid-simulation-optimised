# fluid-simulation-optimised

# Отчет

Измеряю время без всяких оптимизаций при T = 400.

Сделал всего 3 выполнения, среднее время составило **81.87 секунду**

Далее, используя Profiler в CLion составил Flamegraph. На графике отобраажается время затраченное на функции (по горизонтали) и стек вызова (по вертикали)

![image_2024-12-20_21-46-02.png](reference%2Fimage_2024-12-20_21-46-02.png)

По графику видно, что propagate_flow() занимает больше всего времени, а так же  propogate_flow() вызывает очень много вызовов get(). Я начну с небольшого изменения именно в get().

Вместо оригинального get()
```C++
Fixed &get(int x, int y, int dx, int dy) {
        size_t i = ranges::find(deltas, pair(dx, dy)) - deltas.begin();
        assert(i < deltas.size());
        return v[x][y][i];
    }
```
Вместо "дорогих" функций вроде find() и assert() можно использовать битовые логические операторы, что существенно ускорит этот фрагмент кода.
```c++
Fixed &get(int x, int y, int dx, int dy) {
    return v[x][y][((dy & 1) << 1) | (((dx & 1) & ((dx & 2) >> 1)) | ((dy & 1) & ((dy & 2) >> 1)))];
}
```
Это изменение значительно ускорило общее время выполнение программы. За 3 выполнния среднее время составило **26.88 секунд**.
Ускорение работы в 3 раза.

Далее я решил оптимизировать функцию propagate_flow(), используя параллелизм и потоки. 
